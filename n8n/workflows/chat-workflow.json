{
  "name": "AG-MCP Chat with MCP Tools",
  "nodes": [
    {
      "id": "webhook",
      "name": "Chat Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "chat-endpoint",
      "parameters": {
        "httpMethod": "POST",
        "path": "api/chat",
        "responseMode": "lastNode",
        "options": {}
      },
      "notes": "Receives chat requests from API Gateway with MCP context"
    },
    {
      "id": "analyze_intent",
      "name": "Analyze Intent & Route",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300],
      "parameters": {
        "jsCode": "// Extract request data\nconst message = ($json.body?.message || '').toLowerCase();\nconst language = $json.body?.language || 'en';\nconst history = $json.body?.history || [];\nconst mcpServers = $json.body?.mcpServers || { global: [], regional: [], allTools: [] };\nconst detectedRegions = $json.body?.detectedRegions || [];\nconst latitude = $json.body?.latitude;\nconst longitude = $json.body?.longitude;\n\n// Language map\nconst languageMap = {\n  'hi': 'Hindi', 'te': 'Telugu', 'kn': 'Kannada', 'mr': 'Marathi',\n  'gu': 'Gujarati', 'ta': 'Tamil', 'bn': 'Bengali', 'ml': 'Malayalam',\n  'pa': 'Punjabi', 'or': 'Odia', 'sw': 'Swahili', 'am': 'Amharic',\n  'vi': 'Vietnamese', 'th': 'Thai', 'id': 'Indonesian', 'en': 'English',\n  'es': 'Spanish', 'fr': 'French', 'de': 'German', 'pt': 'Portuguese', 'ar': 'Arabic'\n};\nconst langName = languageMap[language] || language;\n\n// Intent detection keywords\nconst intents = [];\n\n// Weather intent\nif (message.match(/weather|forecast|rain|temperature|climate|hot|cold/)) {\n  intents.push('weather');\n}\n\n// Soil intent\nif (message.match(/soil|ph|nitrogen|phosphorus|potassium|nutrient|land/)) {\n  intents.push('soil');\n}\n\n// Fertilizer intent\nif (message.match(/fertilizer|fertiliser|npk|urea|nps|compost|nutrient|manure/)) {\n  intents.push('fertilizer');\n}\n\n// Feed/livestock intent\nif (message.match(/feed|cow|cattle|dairy|livestock|milk|fodder|diet|ration|nutrition/)) {\n  intents.push('feed');\n}\n\n// Crop/plant intent\nif (message.match(/crop|plant|grow|harvest|pest|disease|wheat|maize|rice|vegetable/)) {\n  intents.push('crop');\n}\n\n// Build MCP calls to make\nconst mcpCalls = [];\nconst allServers = [...mcpServers.global, ...mcpServers.regional];\n\n// Weather - AccuWeather or GAP Weather\nif (intents.includes('weather') && latitude && longitude) {\n  const weatherServer = allServers.find(s => s.slug === 'accuweather' || s.slug === 'gap-weather');\n  if (weatherServer) {\n    mcpCalls.push({\n      name: 'weather',\n      url: `https://${weatherServer.slug === 'accuweather' ? 'accuweather-mcp' : 'gap-agriculture-mcp'}.up.railway.app/mcp`,\n      tool: weatherServer.slug === 'accuweather' ? 'get_accuweather_current_conditions' : 'get_weather',\n      args: { latitude, longitude }\n    });\n  }\n}\n\n// Soil - ISDA\nif (intents.includes('soil') && latitude && longitude) {\n  const soilServer = allServers.find(s => s.slug === 'isda-soil');\n  if (soilServer) {\n    mcpCalls.push({\n      name: 'soil',\n      url: 'https://isda-soil-mcp.up.railway.app/mcp',\n      tool: 'get_isda_soil_properties',\n      args: { latitude, longitude }\n    });\n  }\n}\n\n// Fertilizer - NextGen\nif (intents.includes('fertilizer') && latitude && longitude) {\n  const fertServer = allServers.find(s => s.slug === 'nextgen');\n  if (fertServer) {\n    // Detect crop from message\n    const crop = message.includes('maize') || message.includes('corn') ? 'maize' : 'wheat';\n    mcpCalls.push({\n      name: 'fertilizer',\n      url: 'https://nextgen-mcp.up.railway.app/mcp',\n      tool: 'get_fertilizer_recommendation',\n      args: { crop, latitude, longitude }\n    });\n  }\n}\n\n// Feed - Feed Formulation\nif (intents.includes('feed')) {\n  const feedServer = allServers.find(s => s.slug === 'feed-formulation');\n  if (feedServer) {\n    // Search for feeds mentioned or default to common\n    const feedQuery = message.match(/maize|teff|noug|wheat|hay|straw|bran/)?.[0] || 'dairy';\n    mcpCalls.push({\n      name: 'feed',\n      url: 'https://feed-formulation-mcp.up.railway.app/mcp',\n      tool: 'search_feeds',\n      args: { query: feedQuery, limit: 5 }\n    });\n  }\n}\n\nreturn {\n  json: {\n    message: $json.body?.message,\n    language,\n    langName,\n    history,\n    latitude,\n    longitude,\n    detectedRegions,\n    intents,\n    mcpCalls,\n    mcpServers,\n    hasLocation: !!(latitude && longitude)\n  }\n};"
      },
      "notes": "Analyzes user intent and determines which MCP tools to call"
    },
    {
      "id": "call_mcp_servers",
      "name": "Call MCP Servers",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "parameters": {
        "jsCode": "// Call MCP servers based on detected intents\nconst mcpCalls = $json.mcpCalls || [];\nconst results = {};\n\nfor (const call of mcpCalls) {\n  try {\n    const response = await fetch(call.url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json, text/event-stream',\n        'X-Farm-Latitude': String($json.latitude || ''),\n        'X-Farm-Longitude': String($json.longitude || '')\n      },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/call',\n        params: {\n          name: call.tool,\n          arguments: call.args\n        }\n      })\n    });\n    \n    const text = await response.text();\n    // Parse SSE response\n    const dataLine = text.split('\\n').find(l => l.startsWith('data: '));\n    if (dataLine) {\n      const data = JSON.parse(dataLine.replace('data: ', ''));\n      if (data.result?.content?.[0]?.text) {\n        try {\n          results[call.name] = JSON.parse(data.result.content[0].text);\n        } catch {\n          results[call.name] = data.result.content[0].text;\n        }\n      } else if (data.result?.isError) {\n        results[call.name] = { error: data.result.content?.[0]?.text || 'MCP call failed' };\n      }\n    }\n  } catch (e) {\n    results[call.name] = { error: e.message };\n  }\n}\n\nreturn {\n  json: {\n    ...$json,\n    mcpResults: results\n  }\n};"
      },
      "notes": "Calls MCP servers and collects results"
    },
    {
      "id": "prepare_gemini",
      "name": "Prepare Gemini Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300],
      "parameters": {
        "jsCode": "const message = $json.message;\nconst langName = $json.langName;\nconst history = $json.history || [];\nconst mcpResults = $json.mcpResults || {};\nconst detectedRegions = $json.detectedRegions || [];\nconst intents = $json.intents || [];\n\n// Build context from MCP results\nlet mcpContext = '';\n\nif (mcpResults.weather && !mcpResults.weather.error) {\n  const w = mcpResults.weather.current || mcpResults.weather;\n  mcpContext += `\\n\\n**Current Weather Data:**\\n- Temperature: ${w.temperature || w.temp}Â°C\\n- Conditions: ${w.conditions || w.description}\\n- Humidity: ${w.humidity}%\\n- Wind: ${w.wind_speed} ${w.wind_unit || 'km/h'}\\n`;\n}\n\nif (mcpResults.soil && !mcpResults.soil.error) {\n  const s = mcpResults.soil.properties || mcpResults.soil;\n  const props = Object.entries(s).slice(0, 5).map(([k, v]) => {\n    const val = Array.isArray(v) ? v[0]?.value?.value : v;\n    const unit = Array.isArray(v) ? v[0]?.value?.unit : '';\n    return `- ${k}: ${val} ${unit}`;\n  }).join('\\n');\n  mcpContext += `\\n\\n**Soil Properties (from ISDA Africa):**\\n${props}\\n`;\n}\n\nif (mcpResults.fertilizer && !mcpResults.fertilizer.error) {\n  const f = mcpResults.fertilizer;\n  if (f.fertilizers) {\n    mcpContext += `\\n\\n**Fertilizer Recommendations (NextGen):**\\n`;\n    if (f.fertilizers.organic) {\n      mcpContext += `- Compost: ${f.fertilizers.organic.compost} tons/ha\\n- Vermicompost: ${f.fertilizers.organic.vermicompost} tons/ha\\n`;\n    }\n    if (f.fertilizers.inorganic) {\n      mcpContext += `- Urea: ${f.fertilizers.inorganic.urea} kg/ha\\n- NPS: ${f.fertilizers.inorganic.nps} kg/ha\\n`;\n    }\n    if (f.expected_yield) {\n      mcpContext += `- Expected Yield: ${f.expected_yield.value} ${f.expected_yield.unit}\\n`;\n    }\n  }\n}\n\nif (mcpResults.feed && !mcpResults.feed.error) {\n  const feeds = mcpResults.feed.feeds?.feeds || [];\n  if (feeds.length > 0) {\n    mcpContext += `\\n\\n**Available Feeds in Ethiopia (from Feed Database):**\\n`;\n    feeds.slice(0, 5).forEach(f => {\n      mcpContext += `- ${f.fd_name}: ${f.fd_cp?.toFixed(1) || '?'}% protein, ${f.fd_dm?.toFixed(1) || '?'}% dry matter (${f.fd_type})\\n`;\n    });\n  }\n}\n\n// Build system prompt with MCP data\nconst systemPrompt = `You are an expert agricultural advisor for smallholder farmers. IMPORTANT: You MUST respond in ${langName} language only.\n\nYour expertise includes:\n- Crop selection and rotation\n- Pest and disease management\n- Weather-based farming advice\n- Soil health and fertilization\n- Livestock nutrition and feed formulation\n- Irrigation and water management\n\n${mcpContext ? '**REAL-TIME DATA FROM AGRICULTURAL SERVICES:**' + mcpContext : ''}\n\n${detectedRegions.length > 0 ? 'User is located in: ' + detectedRegions.map(r => r.name).join(', ') : ''}\n\nProvide practical, actionable advice suitable for small-scale farmers. Use the real-time data above when available to give specific recommendations. Keep responses concise but helpful. Always respond in ${langName}.\n\nIMPORTANT: When you have specific data (weather, soil, fertilizer, feeds), reference the actual numbers in your response.`;\n\n// Build conversation\nconst contents = [\n  { role: 'user', parts: [{ text: systemPrompt }] },\n  { role: 'model', parts: [{ text: `I understand. I am your agricultural advisor and will respond in ${langName}. I have access to real-time agricultural data for your region.` }] }\n];\n\n// Add history\nfor (const msg of history.slice(-10)) {\n  contents.push({\n    role: msg.isBot ? 'model' : 'user',\n    parts: [{ text: msg.text }]\n  });\n}\n\n// Add current message\ncontents.push({ role: 'user', parts: [{ text: message }] });\n\nreturn {\n  json: {\n    ...$json,\n    requestBody: {\n      contents: contents,\n      generationConfig: {\n        temperature: 0.7,\n        maxOutputTokens: 1024\n      }\n    }\n  }\n};"
      },
      "notes": "Prepares Gemini request with MCP data as context"
    },
    {
      "id": "gemini",
      "name": "Gemini Chat API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 300],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key={{ $env.GEMINI_API_KEY }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "options": {
          "timeout": 30000
        }
      },
      "notes": "Calls Gemini with conversation + MCP context"
    },
    {
      "id": "response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300],
      "parameters": {
        "jsCode": "const response = $json;\nconst prevData = $('Prepare Gemini Request').item.json;\n\ntry {\n  const text = response.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I could not generate a response.';\n  \n  return {\n    json: {\n      success: true,\n      response: text.trim(),\n      language: prevData.language,\n      mcpToolsUsed: Object.keys(prevData.mcpResults || {}),\n      intentsDetected: prevData.intents || [],\n      regionsDetected: prevData.detectedRegions?.map(r => r.name) || []\n    }\n  };\n} catch (e) {\n  return {\n    json: {\n      success: false,\n      response: 'An error occurred processing your request.',\n      error: e.message\n    }\n  };\n}"
      },
      "notes": "Formats final response with metadata"
    }
  ],
  "connections": {
    "Chat Webhook": {
      "main": [[{ "node": "Analyze Intent & Route", "type": "main", "index": 0 }]]
    },
    "Analyze Intent & Route": {
      "main": [[{ "node": "Call MCP Servers", "type": "main", "index": 0 }]]
    },
    "Call MCP Servers": {
      "main": [[{ "node": "Prepare Gemini Request", "type": "main", "index": 0 }]]
    },
    "Prepare Gemini Request": {
      "main": [[{ "node": "Gemini Chat API", "type": "main", "index": 0 }]]
    },
    "Gemini Chat API": {
      "main": [[{ "node": "Format Response", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
