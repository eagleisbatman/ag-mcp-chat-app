{
  "name": "AG-MCP Text-to-Speech",
  "nodes": [
    {
      "id": "webhook",
      "name": "TTS Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "tts-endpoint",
      "parameters": {
        "httpMethod": "POST",
        "path": "api/tts",
        "responseMode": "lastNode",
        "options": {}
      },
      "notes": "Receives TTS requests. Expects: { text, language, voice? }"
    },
    {
      "id": "fetch_mapping",
      "name": "Fetch Voice Mapping",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300],
      "parameters": {
        "method": "GET",
        "url": "={{ $env.API_GATEWAY_URL }}/api/languages/tts-mapping",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "x-api-key", "value": "={{ $env.API_GATEWAY_KEY }}" }
          ]
        },
        "options": { "timeout": 5000 }
      },
      "notes": "Fetches language-to-voice mapping from database via API Gateway"
    },
    {
      "id": "prepare",
      "name": "Prepare TTS Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "parameters": {
        "jsCode": "// Get the original request and the voice mapping\nconst originalRequest = $('TTS Webhook').first().json;\nconst mappingResponse = $json;\n\nconst text = originalRequest.body?.text || \"\";\nconst language = originalRequest.body?.language || \"en\";\nconst userVoice = originalRequest.body?.voice;\n\n// Get voice from database mapping or use default\nlet voiceName = userVoice;\nif (!voiceName) {\n  if (mappingResponse.success && mappingResponse.mapping && mappingResponse.mapping[language]) {\n    voiceName = mappingResponse.mapping[language].voiceId;\n  } else {\n    voiceName = mappingResponse.defaultVoice || 'Puck';\n  }\n}\n\n// Get language name for natural speech prompting\nconst langName = mappingResponse.mapping?.[language]?.languageName || 'English';\n\n// Build prompt with natural speech instructions\nlet prompt;\nif (language !== 'en') {\n  prompt = `Speak this in ${langName}, with a warm and friendly tone like a helpful agricultural advisor:\\n${text}`;\n} else {\n  prompt = `Speak with a warm and friendly tone like a helpful agricultural advisor:\\n${text}`;\n}\n\nreturn [{\n  json: {\n    text,\n    language,\n    voiceName,\n    languageName: langName,\n    prompt,\n    requestBody: {\n      contents: [{ parts: [{ text: prompt }] }],\n      generationConfig: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          voiceConfig: {\n            prebuiltVoiceConfig: { voiceName }\n          }\n        }\n      }\n    }\n  }\n}];"
      },
      "notes": "Prepares Gemini TTS API request with database-driven voice selection"
    },
    {
      "id": "tts_api",
      "name": "Gemini TTS API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 300],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key={{ $env.GEMINI_API_KEY }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "options": {
          "timeout": 60000
        }
      },
      "notes": "Calls Gemini 2.5 Flash Preview TTS with database-selected voice"
    },
    {
      "id": "response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300],
      "parameters": {
        "jsCode": "const response = $json;\n\ntry {\n  const audioData = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;\n  if (!audioData) {\n    return [{ json: { success: false, error: \"No audio generated\" } }];\n  }\n  \n  // WAV file parameters (Gemini outputs 24kHz 16-bit mono PCM)\n  const sampleRate = 24000;\n  const numChannels = 1;\n  const bitsPerSample = 16;\n  \n  // Convert base64 PCM to Buffer\n  const pcmBuffer = Buffer.from(audioData, \"base64\");\n  const dataSize = pcmBuffer.length;\n  \n  // Create WAV header (44 bytes)\n  const wavHeader = Buffer.alloc(44);\n  wavHeader.write(\"RIFF\", 0);                              // ChunkID\n  wavHeader.writeUInt32LE(36 + dataSize, 4);               // ChunkSize\n  wavHeader.write(\"WAVE\", 8);                              // Format\n  wavHeader.write(\"fmt \", 12);                             // Subchunk1ID\n  wavHeader.writeUInt32LE(16, 16);                         // Subchunk1Size (PCM)\n  wavHeader.writeUInt16LE(1, 20);                          // AudioFormat (PCM=1)\n  wavHeader.writeUInt16LE(numChannels, 22);                // NumChannels\n  wavHeader.writeUInt32LE(sampleRate, 24);                 // SampleRate\n  wavHeader.writeUInt32LE(sampleRate * numChannels * bitsPerSample / 8, 28); // ByteRate\n  wavHeader.writeUInt16LE(numChannels * bitsPerSample / 8, 32);              // BlockAlign\n  wavHeader.writeUInt16LE(bitsPerSample, 34);              // BitsPerSample\n  wavHeader.write(\"data\", 36);                             // Subchunk2ID\n  wavHeader.writeUInt32LE(dataSize, 40);                   // Subchunk2Size\n  \n  // Combine header and PCM data\n  const wavBuffer = Buffer.concat([wavHeader, pcmBuffer]);\n  const wavBase64 = wavBuffer.toString(\"base64\");\n  \n  // Calculate duration in seconds\n  const bytesPerSecond = sampleRate * numChannels * bitsPerSample / 8;\n  const duration = Math.round(dataSize / bytesPerSecond);\n  \n  return [{\n    json: {\n      success: true,\n      audioBase64: wavBase64,\n      duration: duration,\n      mimeType: \"audio/wav\"\n    }\n  }];\n} catch (e) {\n  return [{ json: { success: false, error: e.message } }];\n}"
      },
      "notes": "Converts Gemini PCM audio to WAV format with proper headers"
    }
  ],
  "connections": {
    "TTS Webhook": {
      "main": [[{ "node": "Fetch Voice Mapping", "type": "main", "index": 0 }]]
    },
    "Fetch Voice Mapping": {
      "main": [[{ "node": "Prepare TTS Request", "type": "main", "index": 0 }]]
    },
    "Prepare TTS Request": {
      "main": [[{ "node": "Gemini TTS API", "type": "main", "index": 0 }]]
    },
    "Gemini TTS API": {
      "main": [[{ "node": "Format Response", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
