{
  "name": "AG-MCP Text-to-Speech",
  "nodes": [
    {
      "id": "webhook",
      "name": "TTS Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "tts-endpoint",
      "parameters": {
        "httpMethod": "POST",
        "path": "api/tts",
        "responseMode": "lastNode",
        "options": {}
      },
      "notes": "Receives TTS requests. Expects: { text, language, voice? }"
    },
    {
      "id": "fetch_mapping",
      "name": "Fetch Voice Mapping",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300],
      "parameters": {
        "method": "GET",
        "url": "={{ $env.API_GATEWAY_URL }}/api/languages/tts-mapping",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "x-api-key", "value": "={{ $env.API_GATEWAY_KEY }}"}
          ]
        },
        "options": {"timeout": 5000},
        "onError": "continueRegularOutput"
      },
      "notes": "Fetches language-to-voice mapping from database. Falls back gracefully on error."
    },
    {
      "id": "prepare",
      "name": "Prepare TTS Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "parameters": {
        "jsCode": "// Database-driven TTS with 54 language mappings + fallback\nconst originalRequest = $('TTS Webhook').first().json;\nconst mappingResponse = $json;\n\nconst text = originalRequest.body?.text || '';\nconst language = originalRequest.body?.language || 'en';\nconst userVoice = originalRequest.body?.voice;\n\n// Complete fallback mappings for all 54 languages\nconst fallbackMappings = {\n  // Indian Languages (12)\n  'hi': 'Charon', 'te': 'Kore', 'kn': 'Puck', 'ta': 'Zephyr',\n  'mr': 'Charon', 'bn': 'Kore', 'gu': 'Puck', 'ml': 'Zephyr',\n  'pa': 'Charon', 'or': 'Kore', 'as': 'Zephyr', 'ne': 'Puck',\n  // African Languages (11)\n  'sw': 'Puck', 'am': 'Charon', 'aa': 'Kore', 'om': 'Puck',\n  'ti': 'Charon', 'ha': 'Kore', 'yo': 'Puck', 'zu': 'Charon',\n  'ig': 'Kore', 'rw': 'Puck', 'so': 'Charon',\n  // Southeast Asian (8)\n  'vi': 'Kore', 'th': 'Zephyr', 'id': 'Puck', 'fil': 'Leda',\n  'ms': 'Puck', 'my': 'Zephyr', 'km': 'Kore', 'lo': 'Zephyr',\n  // European (14)\n  'en': 'Puck', 'es': 'Charon', 'fr': 'Zephyr', 'de': 'Kore',\n  'pt': 'Puck', 'it': 'Aoede', 'nl': 'Kore', 'pl': 'Charon',\n  'uk': 'Zephyr', 'ru': 'Orus', 'ro': 'Leda', 'el': 'Perseus',\n  'cs': 'Kore', 'sv': 'Zephyr',\n  // Middle Eastern (5)\n  'ar': 'Orus', 'fa': 'Charon', 'tr': 'Kore', 'he': 'Perseus', 'ur': 'Charon',\n  // East Asian (4)\n  'zh-CN': 'Kore', 'zh-TW': 'Kore', 'ja': 'Zephyr', 'ko': 'Leda'\n};\n\nconst fallbackLangNames = {\n  'hi': 'Hindi', 'te': 'Telugu', 'kn': 'Kannada', 'ta': 'Tamil',\n  'mr': 'Marathi', 'bn': 'Bengali', 'gu': 'Gujarati', 'ml': 'Malayalam',\n  'pa': 'Punjabi', 'or': 'Odia', 'as': 'Assamese', 'ne': 'Nepali',\n  'sw': 'Swahili', 'am': 'Amharic', 'aa': 'Afar', 'om': 'Oromo',\n  'ti': 'Tigrinya', 'ha': 'Hausa', 'yo': 'Yoruba', 'zu': 'Zulu',\n  'ig': 'Igbo', 'rw': 'Kinyarwanda', 'so': 'Somali',\n  'vi': 'Vietnamese', 'th': 'Thai', 'id': 'Indonesian', 'fil': 'Filipino',\n  'ms': 'Malay', 'my': 'Burmese', 'km': 'Khmer', 'lo': 'Lao',\n  'en': 'English', 'es': 'Spanish', 'fr': 'French', 'de': 'German',\n  'pt': 'Portuguese', 'it': 'Italian', 'nl': 'Dutch', 'pl': 'Polish',\n  'uk': 'Ukrainian', 'ru': 'Russian', 'ro': 'Romanian', 'el': 'Greek',\n  'cs': 'Czech', 'sv': 'Swedish',\n  'ar': 'Arabic', 'fa': 'Persian', 'tr': 'Turkish', 'he': 'Hebrew', 'ur': 'Urdu',\n  'zh-CN': 'Chinese', 'zh-TW': 'Chinese', 'ja': 'Japanese', 'ko': 'Korean'\n};\n\n// Priority: User preference > Database > Fallback\nlet voiceName = userVoice;\nlet langName = fallbackLangNames[language] || 'English';\nlet usedDatabase = false;\n\nif (!voiceName) {\n  if (mappingResponse.success && mappingResponse.mapping?.[language]) {\n    voiceName = mappingResponse.mapping[language].voiceId;\n    langName = mappingResponse.mapping[language].languageName || langName;\n    usedDatabase = true;\n  } else {\n    voiceName = fallbackMappings[language] || 'Puck';\n  }\n}\n\n// Build prompt for natural speech\nconst prompt = language !== 'en'\n  ? `Speak this in ${langName}, with a warm and friendly tone like a helpful agricultural advisor:\\n${text}`\n  : `Speak with a warm and friendly tone like a helpful agricultural advisor:\\n${text}`;\n\nreturn [{\n  json: {\n    text, language, voiceName, languageName: langName, prompt, usedDatabase,\n    requestBody: {\n      contents: [{ parts: [{ text: prompt }] }],\n      generationConfig: {\n        responseModalities: ['AUDIO'],\n        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName } } }\n      }\n    }\n  }\n}];"
      },
      "notes": "Prepares TTS request with database mappings + complete fallback for all 54 languages"
    },
    {
      "id": "tts_api",
      "name": "Gemini TTS API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 300],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key={{ $env.GEMINI_API_KEY }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "options": {"timeout": 60000}
      },
      "notes": "Calls Gemini 2.5 Flash Preview TTS with selected voice"
    },
    {
      "id": "response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300],
      "parameters": {
        "jsCode": "const response = $json;\n\ntry {\n  const audioData = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;\n  if (!audioData) {\n    return [{ json: { success: false, error: 'No audio generated' } }];\n  }\n  \n  // WAV parameters (Gemini outputs 24kHz 16-bit mono PCM)\n  const sampleRate = 24000, numChannels = 1, bitsPerSample = 16;\n  const pcmBuffer = Buffer.from(audioData, 'base64');\n  const dataSize = pcmBuffer.length;\n  \n  // Create WAV header (44 bytes)\n  const wavHeader = Buffer.alloc(44);\n  wavHeader.write('RIFF', 0);\n  wavHeader.writeUInt32LE(36 + dataSize, 4);\n  wavHeader.write('WAVE', 8);\n  wavHeader.write('fmt ', 12);\n  wavHeader.writeUInt32LE(16, 16);\n  wavHeader.writeUInt16LE(1, 20);\n  wavHeader.writeUInt16LE(numChannels, 22);\n  wavHeader.writeUInt32LE(sampleRate, 24);\n  wavHeader.writeUInt32LE(sampleRate * numChannels * bitsPerSample / 8, 28);\n  wavHeader.writeUInt16LE(numChannels * bitsPerSample / 8, 32);\n  wavHeader.writeUInt16LE(bitsPerSample, 34);\n  wavHeader.write('data', 36);\n  wavHeader.writeUInt32LE(dataSize, 40);\n  \n  const wavBuffer = Buffer.concat([wavHeader, pcmBuffer]);\n  const duration = Math.round(dataSize / (sampleRate * numChannels * bitsPerSample / 8));\n  \n  return [{ json: { success: true, audioBase64: wavBuffer.toString('base64'), duration, mimeType: 'audio/wav' } }];\n} catch (e) {\n  return [{ json: { success: false, error: e.message } }];\n}"
      },
      "notes": "Converts Gemini PCM audio to WAV format"
    }
  ],
  "connections": {
    "TTS Webhook": {"main": [[{"node": "Fetch Voice Mapping", "type": "main", "index": 0}]]},
    "Fetch Voice Mapping": {"main": [[{"node": "Prepare TTS Request", "type": "main", "index": 0}]]},
    "Prepare TTS Request": {"main": [[{"node": "Gemini TTS API", "type": "main", "index": 0}]]},
    "Gemini TTS API": {"main": [[{"node": "Format Response", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1"}
}
